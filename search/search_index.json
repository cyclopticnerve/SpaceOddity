{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SpaceOddity \"It mostly works\" \u2122\u00a9\u00ae Short description Version 0.0.1 Table of Contents Requirements Downloading Installing Usage Uninstalling Documentation Developing Notes Requirements Python 3.10+ Downloading There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/SpaceOddity Installing If you downloaded the zip file, extract it and go to the 'install' directory: $ cd ~/Downloads/SpaceOddity-<version>/install where \\<version> is the version number of the file you downloaded. If you cloned the repo, just go to the 'install' directory: $ cd ~/Downloads/SpaceOddity/install Either way, run the install script: $ ./install.py Usage Read the full documentation . Uninstalling Go to the source folder for SpaceOddity and run the uninstaller: $ cd ~/.local/share/spaceoddity $ ./uninstall.py Documentation See the full documentation . Developing If you are developing this project, make sure you run the \"develop.py\" script first to create the proper virtual environment (venv). Notes blah blah blah -)","title":"Home"},{"location":"#spaceoddity","text":"","title":"SpaceOddity"},{"location":"#it-mostly-works-tm","text":"Short description Version 0.0.1","title":"\"It mostly works\" \u2122\u00a9\u00ae"},{"location":"#table-of-contents","text":"Requirements Downloading Installing Usage Uninstalling Documentation Developing Notes","title":"Table of Contents"},{"location":"#requirements","text":"Python 3.10+","title":"Requirements"},{"location":"#downloading","text":"There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/SpaceOddity","title":"Downloading"},{"location":"#installing","text":"If you downloaded the zip file, extract it and go to the 'install' directory: $ cd ~/Downloads/SpaceOddity-<version>/install where \\<version> is the version number of the file you downloaded. If you cloned the repo, just go to the 'install' directory: $ cd ~/Downloads/SpaceOddity/install Either way, run the install script: $ ./install.py","title":"Installing"},{"location":"#usage","text":"Read the full documentation .","title":"Usage"},{"location":"#uninstalling","text":"Go to the source folder for SpaceOddity and run the uninstaller: $ cd ~/.local/share/spaceoddity $ ./uninstall.py","title":"Uninstalling"},{"location":"#documentation","text":"See the full documentation .","title":"Documentation"},{"location":"#developing","text":"If you are developing this project, make sure you run the \"develop.py\" script first to create the proper virtual environment (venv).","title":"Developing"},{"location":"#notes","text":"blah blah blah -)","title":"Notes"},{"location":"API/src/spaceoddity/","text":"spaceoddity.py The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ cd [path to directory of this file] foo@bar:~[path to directory of this file] ./spaceoddity.py [cmd line] or if installed in a global location: foo@bar:~$ spaceoddity [cmd line] Typical usage is show in the main() method. Spaceoddity Bases: SpaceoddityBase The main class, responsible for the operation of the program Public methods main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. Source code in src/spaceoddity.py class Spaceoddity(SpaceoddityBase): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # NB: used in _enable S_PRG_NAME = \"SpaceOddity\" # dict keys S_KEY_APOD = \"apod\" S_KEY_APOD_DATE = \"date\" S_KEY_APOD_EXP = \"explanation\" S_KEY_APOD_HDURL = \"hdurl\" S_KEY_APOD_TYPE = \"media_type\" S_KEY_APOD_VER = \"service version\" S_KEY_APOD_TITLE = \"title\" S_KEY_APOD_URL = \"url\" S_KEY_FILE_OLD = \"file_old\" # the url to load json from S_APOD_URL = ( \"https://api.nasa.gov/planetary/apod?\" \"api_key=K0sNPQo8Dn9f8kaO35hzs8kUnU9bHwhTtazybTbr\" ) # acceptable types S_MEDIA_TYPES = [\"image\"] # format the current time in a manner that can be syntactically compared S_TIME_FMT = \"%Y%m%d%H%M%S\" # NB: format params are now and file ext S_FILE_FMT = \"wallpaper_{}.{}\" # cmd line options # enable option strings S_ARG_ENABLE_OPTION = \"--enable\" S_ARG_ENABLE_ACTION = \"store_true\" S_ARG_ENABLE_DEST = \"ENABLE_DEST\" S_ARG_DISABLE_DEST = \"DISABLE_DEST\" # I18N: enable mode help S_ARG_ENABLE_HELP = _(\"enable the program\") # disable option strings S_ARG_DISABLE_OPTION = \"--disable\" S_ARG_DISABLE_ACTION = \"store_true\" # I18N: disable mode help S_ARG_DISABLE_HELP = _(\"disable the program\") # messages # TODO: make all msg in color and have start/done/fail # I18N: install cron job S_MSG_CRON_ADD = _(\"Adding cron job... \") # I18N: Uninstall cron job S_MSG_CRON_DEL = _(\"Removing cron job... \") # I18N: Done with cron job S_MSG_DONE = _(\"Done\") # I18N: get initial apod dict # NB: param is dict S_MSG_GET = _(\"Get data from server\") # I18N: no change, exit S_MSG_SAME_URL = _(\"The APOD picture has not changed\") # I18N: new download is not image S_MSG_NOT_IMG = _(\"The new APOD is not an image\") # I18N: download succeeded S_MSG_DL = _(\"Downloaded image\") # I18N: set image as background S_MSG_SET = _(\"Set image as background\") # I18N: delete old image S_MSG_DEL = _(\"Deleted old image\") # errors # I18N: error on initial get # NB: param is error msg S_ERR_GET = _(\"Could not get data from server: {}\") # I18N: could not download new image # NB: param is error S_ERR_DL = _(\"Could not download image: {}\") # I18N: could not set new image # NB: param is error S_ERR_SET = _(\"Could not set new image: {}\") # I18N: could not delete old image # NB: param is error S_ERR_DEL = _(\"Could not delete old image: {}\") # commands S_CMD_LIGHT = ( \"gsettings set org.gnome.desktop.background picture-uri file://{}\" ) S_CMD_DARK = ( \"gsettings set org.gnome.desktop.background picture-uri-dark file://{}\" ) # NB: the env stuff is required to futz w/ the screen from cron (which # technically runs headless) # NB: format params are uid and prg name S_CMD_CRON = ( \"env \" \"DISPLAY=:0 \" \"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/{}/bus \" # TODO: need this? # \"/usr/bin/python3 \" \"{}\" ) # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set default config dict self._dict_cfg = { self.S_KEY_APOD: {}, self.S_KEY_FILE_OLD: \"\", } # location of new file (soon to be old file) self._new_file = \"\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # remove cron job (or skip if not exists) if self._dict_args[self.S_ARG_DISABLE_DEST]: self._disable() self._teardown() sys.exit(0) # check if we are being enabled if self._dict_args[self.S_ARG_ENABLE_DEST]: self._enable() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing res = self._get_apod_dict() self._new_file = self._dict_cfg.get(self.S_KEY_FILE_OLD, \"\") if res: self._get_apod_image() self._do_text() self._set_image() if res: self._delete_old_image() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. If you implement this function. make sure to call super() LAST!!! \"\"\" # get a mutually exclusive group group = self._parser.add_mutually_exclusive_group() # add debug option group.add_argument( self.S_ARG_ENABLE_OPTION, action=self.S_ARG_ENABLE_ACTION, dest=self.S_ARG_ENABLE_DEST, help=self.S_ARG_ENABLE_HELP, ) # add debug option group.add_argument( self.S_ARG_DISABLE_OPTION, action=self.S_ARG_DISABLE_ACTION, dest=self.S_ARG_DISABLE_DEST, help=self.S_ARG_DISABLE_HELP, ) # do setup super()._setup() # -------------------------------------------------------------------------- # Enable cron job # -------------------------------------------------------------------------- def _enable(self): \"\"\" Enable cron job \"\"\" # debug foo if self._cmd_debug: print(\"_enable\") return # show some text print(self.S_MSG_CRON_ADD, end=\"\", flush=True) # */10 * * * * env DISPLAY=:0 # DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus /usr/bin/python3 # /home/dana/.local/spaceoddity/src/spaceoddity.py # spaceoddity # ---------------------------------------------------------------------- # get cron command # set the job command uid = os.getuid() cron_cmd = self.S_CMD_CRON.format(uid, self.S_PRG_NAME) # ---------------------------------------------------------------------- # create cron object # get current user's crontab my_cron = CronTab(user=True) # find 'every' job my_job = None for job in my_cron: # find our job if job.comment == self.S_PRG_NAME: my_job = job break # create new job if necessary if not my_job: my_job = my_cron.new(command=cron_cmd, comment=self.S_PRG_NAME) # set job time my_job.enable() my_job.minute.every(10) # type: ignore # save job parameters my_cron.write() # show some text print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Disable cron job # -------------------------------------------------------------------------- def _disable(self): \"\"\" Disable cron job \"\"\" # debug foo if self._cmd_debug: print(\"_disable\") return # show some text print(self.S_MSG_CRON_DEL, end=\"\", flush=True) # get current user's crontab my_cron = CronTab(user=True) # remove our job for job in my_cron: if job.comment == self.S_PRG_NAME: my_cron.remove(job) # save job parameters my_cron.write() # show some text print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Get json from api.nasa.gov # -------------------------------------------------------------------------- def _get_apod_dict(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_get_apod_dict\") return True # get the nasa json try: # get json from url response = request.urlopen(self.S_APOD_URL) response_text = response.read() except OSError as error: # prob no internet print(self.S_ERR_GET.format(error)) sys.exit(-1) print(self.S_MSG_GET) # ---------------------------------------------------------------------- # get the old and new apod dicts apod_dict_old = self._dict_cfg[self.S_KEY_APOD] apod_dict_new = json.loads(response_text) # check if url is the same if self._check_same_url(apod_dict_old, apod_dict_new): print(self.S_MSG_SAME_URL) return False # check if today's apod is an image (sometimes it's a video) media_type = apod_dict_new[self.S_KEY_APOD_TYPE] if media_type not in self.S_MEDIA_TYPES: print(self.S_MSG_NOT_IMG) return False # apply new dict to config self._dict_cfg[self.S_KEY_APOD] = apod_dict_new return True # -------------------------------------------------------------------------- # Get image from api.nasa.gov # -------------------------------------------------------------------------- def _get_apod_image(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_get_apod_image\") return # get current apod dict apod_dict = self._dict_cfg[self.S_KEY_APOD] # get most appropriate URL src_url = \"\" if self.S_KEY_APOD_HDURL in apod_dict: src_url = apod_dict[self.S_KEY_APOD_HDURL] elif self.S_KEY_APOD_URL in apod_dict: src_url = apod_dict[self.S_KEY_APOD_URL] # create a download path now = datetime.now() str_now = now.strftime(self.S_TIME_FMT) file_ext = src_url.split(\".\")[-1] # get new pic name pic_name = self.S_FILE_FMT.format(str_now, file_ext) pic_path = B.P_DIR_CONF / pic_name # try to download image try: # download the image request.urlretrieve(src_url, pic_path) # store new file self._new_file = str(pic_path) except OSError as error: # this is a fatal error print(self.S_ERR_DL.format(error)) sys.exit(-1) print(self.S_MSG_DL) # -------------------------------------------------------------------------- # Do text overlay # -------------------------------------------------------------------------- def _do_text(self): \"\"\" Description \"\"\" # -------------------------------------------------------------------------- # Set the wallpaper # -------------------------------------------------------------------------- def _set_image(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_set_image\") return try: F.run(self.S_CMD_LIGHT.format(self._new_file)) except F.CNRunError as error: print(self.S_ERR_SET.format(error)) sys.exit(-1) try: F.run(self.S_CMD_DARK.format(self._new_file)) except F.CNRunError as error: print(self.S_ERR_SET.format(error)) sys.exit(-1) print(self.S_MSG_SET) # -------------------------------------------------------------------------- # Delete old image # -------------------------------------------------------------------------- def _delete_old_image(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_delete_old_image\") return # get previous path name file_old = self._dict_cfg[self.S_KEY_FILE_OLD] path_old = Path(file_old) # if it exists, delete it if path_old.exists(): try: path_old.unlink() except OSError as error: # log error print(self.S_ERR_DEL.format(error)) self._dict_cfg[self.S_KEY_FILE_OLD] = self._new_file print(self.S_MSG_DEL) # -------------------------------------------------------------------------- # Check if new URL is same as old URL # -------------------------------------------------------------------------- def _check_same_url(self, old_dict, new_dict): \"\"\" Description \"\"\" # default return result same_url = False # check if the url is the same if ( self.S_KEY_APOD_HDURL in old_dict.keys() and self.S_KEY_APOD_HDURL in new_dict.keys() ): if ( old_dict[self.S_KEY_APOD_HDURL] == new_dict[self.S_KEY_APOD_HDURL] ): same_url = True elif ( self.S_KEY_APOD_URL in old_dict.keys() and self.S_KEY_APOD_URL in new_dict.keys() ): if old_dict[self.S_KEY_APOD_URL] == new_dict[self.S_KEY_APOD_URL]: same_url = True # return the result return same_url __init__() Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/spaceoddity.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set default config dict self._dict_cfg = { self.S_KEY_APOD: {}, self.S_KEY_FILE_OLD: \"\", } # location of new file (soon to be old file) self._new_file = \"\" main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/spaceoddity.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # remove cron job (or skip if not exists) if self._dict_args[self.S_ARG_DISABLE_DEST]: self._disable() self._teardown() sys.exit(0) # check if we are being enabled if self._dict_args[self.S_ARG_ENABLE_DEST]: self._enable() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing res = self._get_apod_dict() self._new_file = self._dict_cfg.get(self.S_KEY_FILE_OLD, \"\") if res: self._get_apod_image() self._do_text() self._set_image() if res: self._delete_old_image() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"spaceoddity.py"},{"location":"API/src/spaceoddity/#spaceodditypy","text":"The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ cd [path to directory of this file] foo@bar:~[path to directory of this file] ./spaceoddity.py [cmd line] or if installed in a global location: foo@bar:~$ spaceoddity [cmd line] Typical usage is show in the main() method.","title":"spaceoddity.py"},{"location":"API/src/spaceoddity/#src.spaceoddity.Spaceoddity","text":"Bases: SpaceoddityBase The main class, responsible for the operation of the program Public methods main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. Source code in src/spaceoddity.py class Spaceoddity(SpaceoddityBase): \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # NB: used in _enable S_PRG_NAME = \"SpaceOddity\" # dict keys S_KEY_APOD = \"apod\" S_KEY_APOD_DATE = \"date\" S_KEY_APOD_EXP = \"explanation\" S_KEY_APOD_HDURL = \"hdurl\" S_KEY_APOD_TYPE = \"media_type\" S_KEY_APOD_VER = \"service version\" S_KEY_APOD_TITLE = \"title\" S_KEY_APOD_URL = \"url\" S_KEY_FILE_OLD = \"file_old\" # the url to load json from S_APOD_URL = ( \"https://api.nasa.gov/planetary/apod?\" \"api_key=K0sNPQo8Dn9f8kaO35hzs8kUnU9bHwhTtazybTbr\" ) # acceptable types S_MEDIA_TYPES = [\"image\"] # format the current time in a manner that can be syntactically compared S_TIME_FMT = \"%Y%m%d%H%M%S\" # NB: format params are now and file ext S_FILE_FMT = \"wallpaper_{}.{}\" # cmd line options # enable option strings S_ARG_ENABLE_OPTION = \"--enable\" S_ARG_ENABLE_ACTION = \"store_true\" S_ARG_ENABLE_DEST = \"ENABLE_DEST\" S_ARG_DISABLE_DEST = \"DISABLE_DEST\" # I18N: enable mode help S_ARG_ENABLE_HELP = _(\"enable the program\") # disable option strings S_ARG_DISABLE_OPTION = \"--disable\" S_ARG_DISABLE_ACTION = \"store_true\" # I18N: disable mode help S_ARG_DISABLE_HELP = _(\"disable the program\") # messages # TODO: make all msg in color and have start/done/fail # I18N: install cron job S_MSG_CRON_ADD = _(\"Adding cron job... \") # I18N: Uninstall cron job S_MSG_CRON_DEL = _(\"Removing cron job... \") # I18N: Done with cron job S_MSG_DONE = _(\"Done\") # I18N: get initial apod dict # NB: param is dict S_MSG_GET = _(\"Get data from server\") # I18N: no change, exit S_MSG_SAME_URL = _(\"The APOD picture has not changed\") # I18N: new download is not image S_MSG_NOT_IMG = _(\"The new APOD is not an image\") # I18N: download succeeded S_MSG_DL = _(\"Downloaded image\") # I18N: set image as background S_MSG_SET = _(\"Set image as background\") # I18N: delete old image S_MSG_DEL = _(\"Deleted old image\") # errors # I18N: error on initial get # NB: param is error msg S_ERR_GET = _(\"Could not get data from server: {}\") # I18N: could not download new image # NB: param is error S_ERR_DL = _(\"Could not download image: {}\") # I18N: could not set new image # NB: param is error S_ERR_SET = _(\"Could not set new image: {}\") # I18N: could not delete old image # NB: param is error S_ERR_DEL = _(\"Could not delete old image: {}\") # commands S_CMD_LIGHT = ( \"gsettings set org.gnome.desktop.background picture-uri file://{}\" ) S_CMD_DARK = ( \"gsettings set org.gnome.desktop.background picture-uri-dark file://{}\" ) # NB: the env stuff is required to futz w/ the screen from cron (which # technically runs headless) # NB: format params are uid and prg name S_CMD_CRON = ( \"env \" \"DISPLAY=:0 \" \"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/{}/bus \" # TODO: need this? # \"/usr/bin/python3 \" \"{}\" ) # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set default config dict self._dict_cfg = { self.S_KEY_APOD: {}, self.S_KEY_FILE_OLD: \"\", } # location of new file (soon to be old file) self._new_file = \"\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # remove cron job (or skip if not exists) if self._dict_args[self.S_ARG_DISABLE_DEST]: self._disable() self._teardown() sys.exit(0) # check if we are being enabled if self._dict_args[self.S_ARG_ENABLE_DEST]: self._enable() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing res = self._get_apod_dict() self._new_file = self._dict_cfg.get(self.S_KEY_FILE_OLD, \"\") if res: self._get_apod_image() self._do_text() self._set_image() if res: self._delete_old_image() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. If you implement this function. make sure to call super() LAST!!! \"\"\" # get a mutually exclusive group group = self._parser.add_mutually_exclusive_group() # add debug option group.add_argument( self.S_ARG_ENABLE_OPTION, action=self.S_ARG_ENABLE_ACTION, dest=self.S_ARG_ENABLE_DEST, help=self.S_ARG_ENABLE_HELP, ) # add debug option group.add_argument( self.S_ARG_DISABLE_OPTION, action=self.S_ARG_DISABLE_ACTION, dest=self.S_ARG_DISABLE_DEST, help=self.S_ARG_DISABLE_HELP, ) # do setup super()._setup() # -------------------------------------------------------------------------- # Enable cron job # -------------------------------------------------------------------------- def _enable(self): \"\"\" Enable cron job \"\"\" # debug foo if self._cmd_debug: print(\"_enable\") return # show some text print(self.S_MSG_CRON_ADD, end=\"\", flush=True) # */10 * * * * env DISPLAY=:0 # DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus /usr/bin/python3 # /home/dana/.local/spaceoddity/src/spaceoddity.py # spaceoddity # ---------------------------------------------------------------------- # get cron command # set the job command uid = os.getuid() cron_cmd = self.S_CMD_CRON.format(uid, self.S_PRG_NAME) # ---------------------------------------------------------------------- # create cron object # get current user's crontab my_cron = CronTab(user=True) # find 'every' job my_job = None for job in my_cron: # find our job if job.comment == self.S_PRG_NAME: my_job = job break # create new job if necessary if not my_job: my_job = my_cron.new(command=cron_cmd, comment=self.S_PRG_NAME) # set job time my_job.enable() my_job.minute.every(10) # type: ignore # save job parameters my_cron.write() # show some text print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Disable cron job # -------------------------------------------------------------------------- def _disable(self): \"\"\" Disable cron job \"\"\" # debug foo if self._cmd_debug: print(\"_disable\") return # show some text print(self.S_MSG_CRON_DEL, end=\"\", flush=True) # get current user's crontab my_cron = CronTab(user=True) # remove our job for job in my_cron: if job.comment == self.S_PRG_NAME: my_cron.remove(job) # save job parameters my_cron.write() # show some text print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Get json from api.nasa.gov # -------------------------------------------------------------------------- def _get_apod_dict(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_get_apod_dict\") return True # get the nasa json try: # get json from url response = request.urlopen(self.S_APOD_URL) response_text = response.read() except OSError as error: # prob no internet print(self.S_ERR_GET.format(error)) sys.exit(-1) print(self.S_MSG_GET) # ---------------------------------------------------------------------- # get the old and new apod dicts apod_dict_old = self._dict_cfg[self.S_KEY_APOD] apod_dict_new = json.loads(response_text) # check if url is the same if self._check_same_url(apod_dict_old, apod_dict_new): print(self.S_MSG_SAME_URL) return False # check if today's apod is an image (sometimes it's a video) media_type = apod_dict_new[self.S_KEY_APOD_TYPE] if media_type not in self.S_MEDIA_TYPES: print(self.S_MSG_NOT_IMG) return False # apply new dict to config self._dict_cfg[self.S_KEY_APOD] = apod_dict_new return True # -------------------------------------------------------------------------- # Get image from api.nasa.gov # -------------------------------------------------------------------------- def _get_apod_image(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_get_apod_image\") return # get current apod dict apod_dict = self._dict_cfg[self.S_KEY_APOD] # get most appropriate URL src_url = \"\" if self.S_KEY_APOD_HDURL in apod_dict: src_url = apod_dict[self.S_KEY_APOD_HDURL] elif self.S_KEY_APOD_URL in apod_dict: src_url = apod_dict[self.S_KEY_APOD_URL] # create a download path now = datetime.now() str_now = now.strftime(self.S_TIME_FMT) file_ext = src_url.split(\".\")[-1] # get new pic name pic_name = self.S_FILE_FMT.format(str_now, file_ext) pic_path = B.P_DIR_CONF / pic_name # try to download image try: # download the image request.urlretrieve(src_url, pic_path) # store new file self._new_file = str(pic_path) except OSError as error: # this is a fatal error print(self.S_ERR_DL.format(error)) sys.exit(-1) print(self.S_MSG_DL) # -------------------------------------------------------------------------- # Do text overlay # -------------------------------------------------------------------------- def _do_text(self): \"\"\" Description \"\"\" # -------------------------------------------------------------------------- # Set the wallpaper # -------------------------------------------------------------------------- def _set_image(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_set_image\") return try: F.run(self.S_CMD_LIGHT.format(self._new_file)) except F.CNRunError as error: print(self.S_ERR_SET.format(error)) sys.exit(-1) try: F.run(self.S_CMD_DARK.format(self._new_file)) except F.CNRunError as error: print(self.S_ERR_SET.format(error)) sys.exit(-1) print(self.S_MSG_SET) # -------------------------------------------------------------------------- # Delete old image # -------------------------------------------------------------------------- def _delete_old_image(self): \"\"\" Description \"\"\" # debug_foo if self._cmd_debug: print(\"_delete_old_image\") return # get previous path name file_old = self._dict_cfg[self.S_KEY_FILE_OLD] path_old = Path(file_old) # if it exists, delete it if path_old.exists(): try: path_old.unlink() except OSError as error: # log error print(self.S_ERR_DEL.format(error)) self._dict_cfg[self.S_KEY_FILE_OLD] = self._new_file print(self.S_MSG_DEL) # -------------------------------------------------------------------------- # Check if new URL is same as old URL # -------------------------------------------------------------------------- def _check_same_url(self, old_dict, new_dict): \"\"\" Description \"\"\" # default return result same_url = False # check if the url is the same if ( self.S_KEY_APOD_HDURL in old_dict.keys() and self.S_KEY_APOD_HDURL in new_dict.keys() ): if ( old_dict[self.S_KEY_APOD_HDURL] == new_dict[self.S_KEY_APOD_HDURL] ): same_url = True elif ( self.S_KEY_APOD_URL in old_dict.keys() and self.S_KEY_APOD_URL in new_dict.keys() ): if old_dict[self.S_KEY_APOD_URL] == new_dict[self.S_KEY_APOD_URL]: same_url = True # return the result return same_url","title":"Spaceoddity"},{"location":"API/src/spaceoddity/#src.spaceoddity.Spaceoddity.__init__","text":"Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/spaceoddity.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # do super init super().__init__() # set default config dict self._dict_cfg = { self.S_KEY_APOD: {}, self.S_KEY_FILE_OLD: \"\", } # location of new file (soon to be old file) self._new_file = \"\"","title":"__init__"},{"location":"API/src/spaceoddity/#src.spaceoddity.Spaceoddity.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/spaceoddity.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # call boilerplate code self._setup() # remove cron job (or skip if not exists) if self._dict_args[self.S_ARG_DISABLE_DEST]: self._disable() self._teardown() sys.exit(0) # check if we are being enabled if self._dict_args[self.S_ARG_ENABLE_DEST]: self._enable() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing res = self._get_apod_dict() self._new_file = self._dict_cfg.get(self.S_KEY_FILE_OLD, \"\") if res: self._get_apod_image() self._do_text() self._set_image() if res: self._delete_old_image() # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"main"},{"location":"API/src/spaceoddity_base/","text":"spaceoddity_base.py The base file for a cli or gui program This file contains all the boring boilerplate code for making a robust CLI/GUI application. It is not intended to be run directly, but rather subclassed. The subclass should contain, at minimum, the main method and the top-level run code (examples are given in the cli/src and gui/src subdirectories of the template directory). SpaceoddityBase The main class, responsible for the operation of the program Public methods main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. Source code in src/spaceoddity_base.py class SpaceoddityBase: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # bools # set load/save oder # NB: if true, only load first file found (cmdline, conf dir, internal) # if false, load all and combine (internal, conf dir, cmdline) B_LOAD_HIGH = False # NB: if true, only save to file found in load # if false, save to all B_SAVE_HIGH = False # -------------------------------------------------------------------------- # strings # short description # pylint: disable=line-too-long # NB: need to keep on one line for replacement S_PP_SHORT_DESC = \"Short description\" # pylint: enable=line-too-long # version string S_PP_VERSION = \"Version 0.0.1\" # config option strings S_ARG_CFG_OPTION = \"-c\" S_ARG_CFG_DEST = \"CFG_DEST\" # I18N: config file option help S_ARG_CFG_HELP = _(\"load configuration from file\") # I18N: config file dest S_ARG_CFG_METAVAR = _(\"FILE\") # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N: debug mode help S_ARG_DBG_HELP = _(\"enable debugging mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # config option strings S_ARG_UNINST_OPTION = \"--uninstall\" S_ARG_UNINST_ACTION = \"store_true\" S_ARG_UNINST_DEST = \"UNINST_DEST\" # I18N: uninstall option help S_ARG_UNINST_HELP = _(\"uninstall this program\") # about string S_ABOUT = ( \"\\n\" \"SpaceOddity\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/SpaceOddity\" ) # default format af log files S_LOG_FMT = \"%(asctime)s [%(levelname)-7s] %(message)s\" S_LOG_DATE_FMT = \"%Y-%m-%d %I:%M:%S %p\" # -------------------------------------------------------------------------- # questions # I18N: answer yes S_ASK_YES = _(\"y\") # I18N: answer no S_ASK_NO = _(\"N\") # NB: format param is prog name # I18N: ask to uninstall S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue?\") # -------------------------------------------------------------------------- # messages # I18N: process aborted S_MSG_ABORT = _(\"Aborted\") # -------------------------------------------------------------------------- # error messages # I18N: an error occurred S_ERR_ERR = _(\"Error:\") # I18N: uninstall not found S_ERR_NO_UNINST = _(\"Uninstall files not found\") # NB: format param is file path # I18N: could not find -c file S_ERR_NO_CFG = _(\"Config file {} not found\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cfg stuff self._path_cfg_def = P_CFG_DEF self._dict_cfg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False self._path_cfg_arg = None # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like running the arg parser and loading config files. \"\"\" # ---------------------------------------------------------------------- # use cmd line # add debug option self._parser.add_argument( self.S_ARG_DBG_OPTION, action=self.S_ARG_DBG_ACTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, ) # always add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, action=self.S_ARG_HLP_ACTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, ) # add uninstall option self._parser.add_argument( self.S_ARG_UNINST_OPTION, action=self.S_ARG_UNINST_ACTION, dest=self.S_ARG_UNINST_DEST, help=self.S_ARG_UNINST_HELP, ) # run the parser args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # ---------------------------------------------------------------------- # check for one-shot args # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): # print default about text print(self.S_ABOUT) print() # print usage and arg info and exit self._parser.print_help() print() sys.exit(0) # set self and lib debug self._cmd_debug = self._dict_args.get( self.S_ARG_DBG_DEST, self._cmd_debug ) F.B_DEBUG = self._cmd_debug # punt to uninstall func if self._dict_args.get(self.S_ARG_UNINST_DEST, False): # uninstall and exit self._do_uninstall() # ---------------------------------------------------------------------- # set props from args # set cfg path self._path_cfg_arg = self._dict_args.get( self.S_ARG_CFG_DEST, self._path_cfg_arg ) # sanity checks if self._path_cfg_def: self._path_cfg_def = Path(self._path_cfg_def) if not self._path_cfg_def.is_absolute(): # make abs rel to self self._path_cfg_def = P_DIR_PRJ / self._path_cfg_def # accept path or str if self._path_cfg_arg: self._path_cfg_arg = Path(self._path_cfg_arg) if not self._path_cfg_arg.is_absolute(): # make abs rel to self self._path_cfg_arg = P_DIR_PRJ / self._path_cfg_arg # ---------------------------------------------------------------------- # use cfg self._load_config() # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # ---------------------------------------------------------------------- # use cfg # call to save config self._save_config() # -------------------------------------------------------------------------- # Load config data from a file # -------------------------------------------------------------------------- def _load_config(self): \"\"\" Load config data from a file This method loads data from a config file. It is written to load a dict from a json file, but it can be used for other formats as well. It uses the values of _dict_cfg (hard-coded), P_CFG_DEF (the default file location), and _path_cfg_arg (file passed on command line) to successively load the config data. \"\"\" # paths of config files l_paths = [self._path_cfg_arg, self._path_cfg_def] # ---------------------------------------------------------------------- # load from highest order only if self.B_LOAD_HIGH: # order of saving (highest to lowest) for a_path in l_paths: # check if valid file (already resolved) if a_path and a_path.exists(): # set whole dict to file try: self._dict_cfg = F.load_paths_into_dict( a_path, self._dict_cfg ) # if we get here, we have loaded the highest file return except OSError as e: # from load_dicts F.printd(self.S_ERR_ERR, str(e)) else: # file does not exist, fall through F.printd( self.S_ERR_ERR, self.S_ERR_NO_CFG.format(a_path), ) # ---------------------------------------------------------------------- # load from both else: try: self._dict_cfg = F.load_paths_into_dict( l_paths, self._dict_cfg ) except OSError as e: # from load_dicts F.printd(self.S_ERR_ERR, str(e)) # -------------------------------------------------------------------------- # Save config data to a file # -------------------------------------------------------------------------- def _save_config(self): \"\"\" Save config data to a file This method saves the config data to all the files it can create. It is written to save a dict to a json file, but it can be used for other formats as well. It uses the values of _dict_cfg, _path_cfg_def, and _path_cfg_arg to save the config data. \"\"\" # paths of config files l_paths = [self._path_cfg_arg, self._path_cfg_def] # ---------------------------------------------------------------------- # check class flag if self.B_SAVE_HIGH: # order of saving (highest to lowest) for a_path in l_paths: # set whole file to dict try: F.save_dict_into_paths(self._dict_cfg, a_path) # if we get here, we have saved the file return except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # ---------------------------------------------------------------------- # save to both else: try: F.save_dict_into_paths(self._dict_cfg, l_paths) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # -------------------------------------------------------------------------- # Handle the --uninstall cmd line op # -------------------------------------------------------------------------- def _do_uninstall(self): \"\"\" Handle the --uninstall cmd line op \"\"\" # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(\"SpaceOddity\"), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask != self.S_ASK_YES: print(self.S_MSG_ABORT) sys.exit(0) # ---------------------------------------------------------------------- # if path exists path_uninst = P_UNINST if not path_uninst.exists(): path_uninst = P_UNINST_DIST # format cmd line cmd = str(path_uninst) + \" -f -q\" if self._cmd_debug: cmd += \" -d\" # ---------------------------------------------------------------------- try: cp = F.run(cmd, shell=True) print(cp.stdout) print(cp.stderr) sys.exit(0) except F.CNRunError as e: print(e.output) sys.exit(e.returncode) __init__() Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/spaceoddity_base.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cfg stuff self._path_cfg_def = P_CFG_DEF self._dict_cfg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False self._path_cfg_arg = None","title":"spaceoddity_base.py"},{"location":"API/src/spaceoddity_base/#spaceoddity_basepy","text":"The base file for a cli or gui program This file contains all the boring boilerplate code for making a robust CLI/GUI application. It is not intended to be run directly, but rather subclassed. The subclass should contain, at minimum, the main method and the top-level run code (examples are given in the cli/src and gui/src subdirectories of the template directory).","title":"spaceoddity_base.py"},{"location":"API/src/spaceoddity_base/#src.spaceoddity_base.SpaceoddityBase","text":"The main class, responsible for the operation of the program Public methods main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. Source code in src/spaceoddity_base.py class SpaceoddityBase: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # bools # set load/save oder # NB: if true, only load first file found (cmdline, conf dir, internal) # if false, load all and combine (internal, conf dir, cmdline) B_LOAD_HIGH = False # NB: if true, only save to file found in load # if false, save to all B_SAVE_HIGH = False # -------------------------------------------------------------------------- # strings # short description # pylint: disable=line-too-long # NB: need to keep on one line for replacement S_PP_SHORT_DESC = \"Short description\" # pylint: enable=line-too-long # version string S_PP_VERSION = \"Version 0.0.1\" # config option strings S_ARG_CFG_OPTION = \"-c\" S_ARG_CFG_DEST = \"CFG_DEST\" # I18N: config file option help S_ARG_CFG_HELP = _(\"load configuration from file\") # I18N: config file dest S_ARG_CFG_METAVAR = _(\"FILE\") # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N: debug mode help S_ARG_DBG_HELP = _(\"enable debugging mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # config option strings S_ARG_UNINST_OPTION = \"--uninstall\" S_ARG_UNINST_ACTION = \"store_true\" S_ARG_UNINST_DEST = \"UNINST_DEST\" # I18N: uninstall option help S_ARG_UNINST_HELP = _(\"uninstall this program\") # about string S_ABOUT = ( \"\\n\" \"SpaceOddity\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/SpaceOddity\" ) # default format af log files S_LOG_FMT = \"%(asctime)s [%(levelname)-7s] %(message)s\" S_LOG_DATE_FMT = \"%Y-%m-%d %I:%M:%S %p\" # -------------------------------------------------------------------------- # questions # I18N: answer yes S_ASK_YES = _(\"y\") # I18N: answer no S_ASK_NO = _(\"N\") # NB: format param is prog name # I18N: ask to uninstall S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue?\") # -------------------------------------------------------------------------- # messages # I18N: process aborted S_MSG_ABORT = _(\"Aborted\") # -------------------------------------------------------------------------- # error messages # I18N: an error occurred S_ERR_ERR = _(\"Error:\") # I18N: uninstall not found S_ERR_NO_UNINST = _(\"Uninstall files not found\") # NB: format param is file path # I18N: could not find -c file S_ERR_NO_CFG = _(\"Config file {} not found\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cfg stuff self._path_cfg_def = P_CFG_DEF self._dict_cfg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False self._path_cfg_arg = None # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like running the arg parser and loading config files. \"\"\" # ---------------------------------------------------------------------- # use cmd line # add debug option self._parser.add_argument( self.S_ARG_DBG_OPTION, action=self.S_ARG_DBG_ACTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, ) # always add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, action=self.S_ARG_HLP_ACTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, ) # add uninstall option self._parser.add_argument( self.S_ARG_UNINST_OPTION, action=self.S_ARG_UNINST_ACTION, dest=self.S_ARG_UNINST_DEST, help=self.S_ARG_UNINST_HELP, ) # run the parser args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # ---------------------------------------------------------------------- # check for one-shot args # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): # print default about text print(self.S_ABOUT) print() # print usage and arg info and exit self._parser.print_help() print() sys.exit(0) # set self and lib debug self._cmd_debug = self._dict_args.get( self.S_ARG_DBG_DEST, self._cmd_debug ) F.B_DEBUG = self._cmd_debug # punt to uninstall func if self._dict_args.get(self.S_ARG_UNINST_DEST, False): # uninstall and exit self._do_uninstall() # ---------------------------------------------------------------------- # set props from args # set cfg path self._path_cfg_arg = self._dict_args.get( self.S_ARG_CFG_DEST, self._path_cfg_arg ) # sanity checks if self._path_cfg_def: self._path_cfg_def = Path(self._path_cfg_def) if not self._path_cfg_def.is_absolute(): # make abs rel to self self._path_cfg_def = P_DIR_PRJ / self._path_cfg_def # accept path or str if self._path_cfg_arg: self._path_cfg_arg = Path(self._path_cfg_arg) if not self._path_cfg_arg.is_absolute(): # make abs rel to self self._path_cfg_arg = P_DIR_PRJ / self._path_cfg_arg # ---------------------------------------------------------------------- # use cfg self._load_config() # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # ---------------------------------------------------------------------- # use cfg # call to save config self._save_config() # -------------------------------------------------------------------------- # Load config data from a file # -------------------------------------------------------------------------- def _load_config(self): \"\"\" Load config data from a file This method loads data from a config file. It is written to load a dict from a json file, but it can be used for other formats as well. It uses the values of _dict_cfg (hard-coded), P_CFG_DEF (the default file location), and _path_cfg_arg (file passed on command line) to successively load the config data. \"\"\" # paths of config files l_paths = [self._path_cfg_arg, self._path_cfg_def] # ---------------------------------------------------------------------- # load from highest order only if self.B_LOAD_HIGH: # order of saving (highest to lowest) for a_path in l_paths: # check if valid file (already resolved) if a_path and a_path.exists(): # set whole dict to file try: self._dict_cfg = F.load_paths_into_dict( a_path, self._dict_cfg ) # if we get here, we have loaded the highest file return except OSError as e: # from load_dicts F.printd(self.S_ERR_ERR, str(e)) else: # file does not exist, fall through F.printd( self.S_ERR_ERR, self.S_ERR_NO_CFG.format(a_path), ) # ---------------------------------------------------------------------- # load from both else: try: self._dict_cfg = F.load_paths_into_dict( l_paths, self._dict_cfg ) except OSError as e: # from load_dicts F.printd(self.S_ERR_ERR, str(e)) # -------------------------------------------------------------------------- # Save config data to a file # -------------------------------------------------------------------------- def _save_config(self): \"\"\" Save config data to a file This method saves the config data to all the files it can create. It is written to save a dict to a json file, but it can be used for other formats as well. It uses the values of _dict_cfg, _path_cfg_def, and _path_cfg_arg to save the config data. \"\"\" # paths of config files l_paths = [self._path_cfg_arg, self._path_cfg_def] # ---------------------------------------------------------------------- # check class flag if self.B_SAVE_HIGH: # order of saving (highest to lowest) for a_path in l_paths: # set whole file to dict try: F.save_dict_into_paths(self._dict_cfg, a_path) # if we get here, we have saved the file return except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # ---------------------------------------------------------------------- # save to both else: try: F.save_dict_into_paths(self._dict_cfg, l_paths) except OSError as e: # from save_dict F.printd(self.S_ERR_ERR, str(e)) # -------------------------------------------------------------------------- # Handle the --uninstall cmd line op # -------------------------------------------------------------------------- def _do_uninstall(self): \"\"\" Handle the --uninstall cmd line op \"\"\" # ask to uninstall str_ask = F.dialog( self.S_ASK_UNINST.format(\"SpaceOddity\"), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask != self.S_ASK_YES: print(self.S_MSG_ABORT) sys.exit(0) # ---------------------------------------------------------------------- # if path exists path_uninst = P_UNINST if not path_uninst.exists(): path_uninst = P_UNINST_DIST # format cmd line cmd = str(path_uninst) + \" -f -q\" if self._cmd_debug: cmd += \" -d\" # ---------------------------------------------------------------------- try: cp = F.run(cmd, shell=True) print(cp.stdout) print(cp.stderr) sys.exit(0) except F.CNRunError as e: print(e.output) sys.exit(e.returncode)","title":"SpaceoddityBase"},{"location":"API/src/spaceoddity_base/#src.spaceoddity_base.SpaceoddityBase.__init__","text":"Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/spaceoddity_base.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cfg stuff self._path_cfg_def = P_CFG_DEF self._dict_cfg = {} # log stuff self._logger = logging.getLogger(__name__) logging.basicConfig( filename=P_LOG_DEF, level=logging.INFO, format=self.S_LOG_FMT, datefmt=self.S_LOG_DATE_FMT, ) # cmd line stuff self._parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # set arg defaults self._dict_args = {} self._cmd_debug = False self._path_cfg_arg = None","title":"__init__"}]}